""" CSG Fusion and SDF Sampler.
The grid_global_samp is defined following GenSDF: https://arxiv.org/abs/2206.02780.
"""


import torch
import torch.nn.functional as F
import numpy as np
import os
from scipy.spatial import cKDTree
import trimesh
import open3d as o3d




class SDFSampler:
    def __init__(self, conf, dataname,csg_sdf1,csg_sdf2,gpu):
        super(SDFSampler, self).__init__()
        self.device = torch.device('cuda')
        torch.cuda.set_device(gpu)
        self.conf = conf

        self.data_dir = conf.get_string('data_dir')
        self.np_data_name = dataname + '.pt'
        self.process_data(self.data_dir, dataname,csg_sdf1,csg_sdf2)

        print('Loading data: ...')
        prep_data = torch.load(os.path.join(self.data_dir, self.np_data_name))
        self.sample = prep_data["query_points"].to(self.device)
        self.sample_sdf = prep_data["query_points_sdf"].to(self.device)
        self.sample_points_num = self.sample.shape[0]-1

        print('Load data: End')

    def train_data(self, batch_size):
        index_coarse = np.random.choice(10, 1)
        index_fine = np.random.choice(self.sample_points_num//10, batch_size, replace = False)
        index = index_fine * 10 + index_coarse
        sample = self.sample[index]
        sample_sdf = self.sample_sdf[index]

        return  sample, sample_sdf



    def process_data(self,data_dir, dataname,csg_sdf1,csg_sdf2):

        print('Sample around SDF volume...')

        # generate query from range [-1 1]
        def gen_grid(start, end, num):
            x = np.linspace(start,end,num=num)
            y = np.linspace(start,end,num=num)
            z = np.linspace(start,end,num=num)
            g = np.meshgrid(x,y,z)
            positions = np.vstack(map(np.ravel, g))
            return positions.swapaxes(0,1)

        def gaussian(vals, sigma=1, mu=0):
            return 1/np.sqrt(2*np.pi*sigma) * torch.exp(-(vals-mu)**2/(2*sigma**2))


        grid_global_samp = 200000
        dot5 = gen_grid(-0.5,0.5, 120)
        dot10 = gen_grid(-1.0, 1.0, 120)
        grid = np.concatenate((dot5,dot10))
        grid = torch.from_numpy(grid).to(self.device).float()
        grid_global = grid[ torch.randperm(grid.shape[0])[0:grid_global_samp] ]
        
        grid_global_sdf = torch.max(csg_sdf1(grid_global),csg_sdf2(grid_global))

        gaussian_sigma = 1e-2

        pts = grid_global

        
        N = 150000
        cur_pts, cur_n = [], 0	
        cur_sdf = []
        i = 0
        while cur_n < N:
            i += 1
            thresholds = torch.rand((pts.shape[0],1))
            sdf_values = torch.max(csg_sdf1(pts),csg_sdf2(pts))    # CSG Intersection: max(f_co,f_ro)
            wghts = gaussian(sdf_values, sigma=gaussian_sigma)
            
            pts = pts[(thresholds < wghts)[:,0], :]
            sdf_values = sdf_values[(thresholds < wghts)[:,0], :]

            cur_pts.append(pts)
            cur_sdf.append(sdf_values)

            cur_n += pts.shape[0]

        if (i > 50):
            # this warning indicates that either the number of points being generated by point_generator
            # is too low, or the function being importance sampled from is incredbily sparse/sharp
            print(f'Warning!! sampling iterated {i} times.')

        total_pts = torch.cat(cur_pts, dim=0)
        total_sdf = torch.cat(cur_sdf, dim=0)

        indices = torch.randperm(total_pts.shape[0])[:N]
        grid_surface = total_pts[indices]
        grid_surface_sdf = total_sdf[indices]

        print('Sampling DONE')

        pcd = o3d.geometry.PointCloud()
        pcd.points = o3d.utility.Vector3dVector(grid_surface.detach().cpu().numpy())
        o3d.io.write_point_cloud(os.path.join(data_dir, dataname)+'.ply', pcd)


        
        print("Saving files...")
        torch.save( {
                    "query_points":torch.cat((grid_global,grid_surface),dim=0),
                    "query_points_sdf":torch.cat((grid_global_sdf,grid_surface_sdf),dim=0),
                    },
                    os.path.join(data_dir, dataname)+'.pt')
        print("Done")



